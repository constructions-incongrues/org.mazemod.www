<?php

/**
 * stream actions.
 *
 * @package    mazemod
 * @subpackage tracks
 * @author     Michel Bertier <mbertier@parishq.net>
 * @version    SVN: $Id: actions.class.php 2692 2006-11-15 21:03:55Z fabien $
 */
class tracksActions extends sfActions
{
    /**
     * Returns an XSPF document of tracks to stream depending on requested tag.
     *
     * @requestparam   string    (optional)tag
     */
    public function executeList()
    {
        $c = new Criteria();

        // Build specialized criteria if one or more tags are requested
        if ($this->getRequest()->hasParameter('tags'))
        {
            $c = TagPeer::getTaggedWithCriteria('Track', $this->getRequestParameter('tags'));
        }

        // Retrieve tracks from database
        if (!$tracks = TrackPeer::doSelectEnabled($c))
        {
            $tracks = array();
        }
        shuffle($tracks);

        // Get playlist in the requested format
        // TODO : plutot implÃ©menter une logique de driver dans mmPlaylistGenerator
        $method_name = sprintf('getPlaylistAs%s', ucfirst($this->getRequestParameter('sf_format')));
        $playlist = call_user_func(array($this, $method_name), $tracks, 'all', $this->getResponse());

        // Pass document to view
        $this->playlist = $playlist;

        // Absolutely no layout
        sfConfig::set('sf_web_debug', false);

        return sfView::SUCCESS;
    }

    public function executeListRandom(sfWebRequest $request)
    {
        $c = new Criteria();
        $c->add(TrackPeer::CONVERTED_FILENAME, null, Criteria::ISNOTNULL);
        $c->add(TrackPeer::IS_ENABLED, true);
        $c->add(TrackPeer::IS_METADATA_COMPLETE, true);
        $c->setLimit(2000);
        $tracks = TrackPeer::doSelect($c) or array();
        shuffle($tracks);

        // Build playlist
        $playlist = $this->getPlaylistAsXspf($tracks, 'Random', $this->getResponse());

        $this->playlist = $playlist;

        // Absolutely no layout
        sfConfig::set('sf_web_debug', false);

        return sfView::SUCCESS;
    }

    /**
     * Returns all available tags as an xml document.
     */
    public function executeTags()
    {
        // Retrieve available tags from database
        $this->forward404Unless($tags = TagPeer::getAll(), 'No tags available. Come back later !');

        // Create XML document
        $xml_str = "<?xml version='1.0' standalone='yes' ?><tags />";
        $xml_doc = simplexml_load_string($xml_str);
        foreach ($tags as $tag)
        {
            $xml_doc->addChild('tag', $tag->getName());
        }

        // Pass document to view
        $this->xml_doc = $xml_doc;

        // Serve XML appropriately
        $this->getResponse()->setContentType('text/xml');

        // Absolutely no layout
        sfConfig::set('sf_web_debug', false);

        return sfView::SUCCESS;
    }

    /**
     * Displays an XSPF document of all requested playlist tracks.
     *
     * @requestparam  int  playlist_id
     */
    public function executePlaylist(sfWebRequest $request)
    {
        // Fetch playlist
        $this->forward404Unless(
        $propel_playlist = PlaylistPeer::retrieveByPK($this->getRequestParameter('playlist_id')),
        sprintf('No playlist with id "%d"', $this->getRequestParameter('playlist_id'))
        );

        // TODO : driver based playlist generator
        switch ($request->getParameter('sf_format'))
        {
            case 'zip':
                // Create archive
                $this->playlist = $this->getPlaylistAsZip(
                $propel_playlist->getTracks(),
                $propel_playlist->getTitle(),
                $this->getResponse());

                break;

            case 'xspf':
                // Build XSPF document
                $xspf_playlist = new mmPlaylistGenerator();
                $xspf_playlist->setPlaylist($propel_playlist);

                // Pass XSPF document to view
                $this->playlist = $xspf_playlist;

                // Set appropriate headers
                $this->getResponse()->setContentType('application/xspf+xml');

                break;

            case 'txt':
                // Pass propel playlist to view
                $this->playlist = $propel_playlist;

                // Set appropriate headers
                $this->getResponse()->setContentType('text/plain');

                break;
        }

        // Absolutely no layout
        sfConfig::set('sf_web_debug', false);

        return sfView::SUCCESS;
    }

    /**
     * Deprecated ?
     */
    private function getPlaylistAsXspf(array $tracks, $playlist_title, sfWebResponse $response)
    {
        // Build XSPF document
        $playlist = new mmPlaylistGenerator();

        // TODO : code some autogenerated fun
        $playlist->setTitle($playlist_title);
        $playlist->setAuthor('The Mazemod.org mighty robot');
        $playlist->setTracks($tracks);

        // Set appropriate headers
        $this->getResponse()->setContentType('application/xspf+xml');

        return $playlist;
    }

    /**
     * Generates zip archive for playlist.
     *
     * @param $tracks
     * @param $playlist_title
     * @param $response
     *
     * TODO : implement cache
     */
    private function getPlaylistAsZip(array $tracks, $playlist_title, sfWebResponse $response)
    {
        // Calculate archive path
        $archive_path = sprintf('/tmp/%s.zip', md5($playlist_title));

        // Delete eventual preceding archive
        unlink($archive_path);

        // Create new archive
        $archive = new ZipArchive();
        if ($archive->open($archive_path, ZipArchive::CREATE) !== true)
        {
            throw new RuntimeException(sprintf('Cannot open archive "%s"', $archive_path));
        }

        // Gather playlist tracks' paths
        foreach ($tracks as $track)
        {
            $track_path = $track->getPath(sfConfig::get('sf_root_dir'));
            if (is_readable($track_path))
            {
                // Append track to archive
                $archive->addFile($track_path, basename($track_path));
            }
            else
            {
                $this->getLogger()->warning(sprintf('{%s} Unable to read "%s", skipping', __METHOD__, $track_path));
            }
        }

        // Close archive
        $archive->close();

        // Prepare response
        $this->archive_path = $archive_path; // TODO : UGLYYYYYYYY !
        $response->setContentType('application/zip');
        $response->setHttpHeader('content-length', filesize($archive_path));

        return $archive;
    }
}